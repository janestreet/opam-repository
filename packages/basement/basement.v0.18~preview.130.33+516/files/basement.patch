diff --git a/src/basement.ml b/src/basement.ml
index 71402ce..98c9d45 100644
--- a/src/basement.ml
+++ b/src/basement.ml
@@ -7,4 +7,3 @@ module Portable_atomic = Portable_atomic
 module Portable_lazy = Portable_lazy
 module Stdlib_iarray_labels = Stdlib_iarray_labels
 module Stdlib_shim = Stdlib_shim
-module Stdlib_shim_upstream = Stdlib_shim_upstream
diff --git a/src/capsule_condition.h b/src/capsule_condition.h
index 90690a0..7701e02 100644
--- a/src/capsule_condition.h
+++ b/src/capsule_condition.h
@@ -8,57 +8,103 @@
 
 #ifdef CAML_INTERNALS
 
-#include <string.h>
 #include <errno.h>
 #include <limits.h>
+#include <string.h>
 #include <unistd.h>
-#include <sys/syscall.h>
-#include <linux/futex.h>
 
-#include "caml/mlvalues.h"
 #include "caml/memory.h"
+#include "caml/mlvalues.h"
 
 #include "capsule_mutex.h"
 
+#ifdef __APPLE__
+#include <pthread.h>
 typedef struct {
   _Atomic uint64_t counter;
-} * capsule_condition;
+  pthread_mutex_t mut;
+  pthread_cond_t cond;
+} *capsule_condition;
+#else
+#include <linux/futex.h>
+#include <sys/syscall.h>
+typedef struct {
+  _Atomic uint64_t counter;
+} *capsule_condition;
+#endif
 #define Condition_val(v) (*((capsule_condition *)Data_custom_val(v)))
 
 #define CONDITION_SUCCESS 0
 
 Caml_inline int capsule_condition_signal(capsule_condition cond) {
   atomic_fetch_add(&cond->counter, 1);
-  if (syscall(SYS_futex, &cond->counter, FUTEX_WAKE_PRIVATE, 1, NULL, NULL, 0) == -1) {
+#ifdef __APPLE__
+  if (pthread_mutex_lock(&cond->mut)) {
+    caml_fatal_error("Failed to acquire futex lock.");
+  }
+  int rc = pthread_cond_signal(&cond->cond);
+  if (pthread_mutex_unlock(&cond->mut)) {
+    caml_fatal_error("Failed to release futex lock.");
+  }
+  return rc;
+#else
+  if (syscall(SYS_futex, &cond->counter, FUTEX_WAKE_PRIVATE, 1, NULL, NULL,
+              0) == -1) {
     return errno;
   }
   return CONDITION_SUCCESS;
+#endif
 }
 
 Caml_inline int capsule_condition_broadcast(capsule_condition cond) {
   atomic_fetch_add(&cond->counter, 1);
-  if (syscall(SYS_futex, &cond->counter, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0) ==
-      -1) {
+#ifdef __APPLE__
+  if (pthread_mutex_lock(&cond->mut)) {
+    caml_fatal_error("Failed to acquire futex lock.");
+  }
+  int rc = pthread_cond_broadcast(&cond->cond);
+  if (pthread_mutex_unlock(&cond->mut)) {
+    caml_fatal_error("Failed to release futex lock.");
+  }
+  return rc;
+#else
+  if (syscall(SYS_futex, &cond->counter, FUTEX_WAKE_PRIVATE, INT_MAX, NULL,
+              NULL, 0) == -1) {
     return errno;
   }
   return CONDITION_SUCCESS;
+#endif
 }
 
-Caml_inline int capsule_condition_wait(capsule_condition cond, capsule_mutex mut) {
+Caml_inline int capsule_condition_wait(capsule_condition cond,
+                                       capsule_mutex mut) {
   // Save and restore owner, as the current fiber may be a descendant.
-  uint64_t old_count = atomic_load(&cond->counter);
   fiber_t owner = atomic_load_explicit(&mut->owner, memory_order_relaxed);
+  uint64_t old_count = atomic_load(&cond->counter);
 
-  // If the mutex operations fail, the condition is in an inconsistent state and it's
-  // not safe to return to OCaml.
+  // If the mutex operations fail, the condition is in an inconsistent state and
+  // it's not safe to return to OCaml.
   if (capsule_mutex_unlock(mut) != MUTEX_SUCCESS) {
     caml_fatal_error("Failed to release mutex.");
   }
 
   caml_enter_blocking_section();
+#ifdef __APPLE__
+  if (pthread_mutex_lock(&cond->mut)) {
+    caml_fatal_error("Failed to acquire futex lock.");
+  }
+  int rc = CONDITION_SUCCESS;
+  if (atomic_load(&cond->counter) == old_count) {
+    rc = pthread_cond_wait(&cond->cond, &cond->mut);
+  }
+  if (pthread_mutex_unlock(&cond->mut)) {
+    caml_fatal_error("Failed to release futex lock.");
+  }
+#else
   int rc = syscall(SYS_futex, &cond->counter, FUTEX_WAIT_PRIVATE, old_count,
                    NULL, NULL, 0);
   int futex_errno = errno;
+#endif
   // Re-aquire the domain lock to avoid blocking other domains on our systhreads
   caml_leave_blocking_section();
 
@@ -67,10 +113,14 @@ Caml_inline int capsule_condition_wait(capsule_condition cond, capsule_mutex mut
   }
   atomic_store_explicit(&mut->owner, owner, memory_order_relaxed);
 
+#ifdef __APPLE__
+  return rc;
+#else
   if (rc == -1 && futex_errno != EAGAIN) {
     return futex_errno;
   }
   return CONDITION_SUCCESS;
+#endif
 }
 
 Caml_inline int capsule_condition_create(capsule_condition *res) {
@@ -79,13 +129,25 @@ Caml_inline int capsule_condition_create(capsule_condition *res) {
     return ENOMEM;
   }
   atomic_store(&cond->counter, 0);
+#ifdef __APPLE__
+  if (pthread_mutex_init(&cond->mut, NULL)) {
+    caml_fatal_error("Failed to create futex mut.");
+  }
+  if (pthread_cond_init(&cond->cond, NULL)) {
+    caml_fatal_error("Failed to create futex cond.");
+  }
+#endif
   *res = cond;
   return CONDITION_SUCCESS;
 }
 
-Caml_inline int capsule_condition_destroy(capsule_condition c) {
-  caml_stat_free(c);
+Caml_inline int capsule_condition_destroy(capsule_condition cond) {
+#ifdef __APPLE__
+  pthread_cond_destroy(&cond->cond);
+  pthread_mutex_destroy(&cond->mut);
+#endif
+  caml_stat_free(cond);
   return CONDITION_SUCCESS;
 }
 
-#endif /* CAML_INTERNALS */
+#endif /* CAML_INTERNALS */
\ No newline at end of file
diff --git a/src/capsule_mutex.h b/src/capsule_mutex.h
index 8153e4d..7240663 100644
--- a/src/capsule_mutex.h
+++ b/src/capsule_mutex.h
@@ -6,11 +6,18 @@
 
 #include <assert.h>
 #include <stdbool.h>
-#include <semaphore.h>
 #include <string.h>
 #include <errno.h>
 #include <pthread.h>
 
+#ifdef __APPLE__
+#include <dispatch/dispatch.h>
+#define platform_sem_t dispatch_semaphore_t
+#else
+#include <semaphore.h>
+#define platform_sem_t sem_t
+#endif
+
 #include "caml/mlvalues.h"
 #include "caml/memory.h"
 
@@ -71,7 +78,7 @@ static bool capsule_fiber_descends_from(fiber_t parent) {
 }
 
 typedef struct {
-  sem_t sem;
+  platform_sem_t sem;
   /* ID of the fiber that has locked the mutex. FIBER_NONE if the mutex is unlocked. */
   _Atomic fiber_t owner;
 } * capsule_mutex;
@@ -81,6 +88,12 @@ typedef struct {
 
 Caml_inline int capsule_mutex_lock(capsule_mutex mut) {
 
+#ifdef __APPLE__
+  if (dispatch_semaphore_wait(mut->sem, DISPATCH_TIME_NOW) == MUTEX_SUCCESS) {
+    atomic_store_explicit(&mut->owner, capsule_fiber_current(), memory_order_relaxed);
+    return MUTEX_SUCCESS;
+  }
+#else
   if (sem_trywait(&mut->sem) == MUTEX_SUCCESS) {
     atomic_store_explicit(&mut->owner, capsule_fiber_current(), memory_order_relaxed);
     return MUTEX_SUCCESS;
@@ -89,6 +102,7 @@ Caml_inline int capsule_mutex_lock(capsule_mutex mut) {
   } else if (errno != EAGAIN) {
     return errno;
   }
+#endif
 
   if (capsule_fiber_descends_from(
           atomic_load_explicit(&mut->owner, memory_order_relaxed))) {
@@ -97,9 +111,17 @@ Caml_inline int capsule_mutex_lock(capsule_mutex mut) {
   }
 
   caml_enter_blocking_section();
+#ifdef __APPLE__
+  dispatch_semaphore_wait(mut->sem, DISPATCH_TIME_FOREVER);
+#else
   int rc = sem_wait(&mut->sem);
+#endif
   caml_leave_blocking_section();
 
+#ifdef __APPLE__
+  atomic_store_explicit(&mut->owner, capsule_fiber_current(), memory_order_relaxed);
+  return MUTEX_SUCCESS;
+#else
   if (rc == MUTEX_SUCCESS) {
     atomic_store_explicit(&mut->owner, capsule_fiber_current(), memory_order_relaxed);
     return MUTEX_SUCCESS;
@@ -107,6 +129,7 @@ Caml_inline int capsule_mutex_lock(capsule_mutex mut) {
     return capsule_mutex_lock(mut);
   }
   return errno;
+#endif
 }
 
 Caml_inline int capsule_mutex_unlock(capsule_mutex mut) {
@@ -116,10 +139,15 @@ Caml_inline int capsule_mutex_unlock(capsule_mutex mut) {
     return EPERM;
   }
   atomic_store_explicit(&mut->owner, FIBER_NONE, memory_order_relaxed);
+#ifdef __APPLE__
+  dispatch_semaphore_signal(mut->sem);
+  return MUTEX_SUCCESS;
+#else
   if (sem_post(&mut->sem) == MUTEX_SUCCESS) {
     return MUTEX_SUCCESS;
   }
   return errno;
+#endif
 }
 
 Caml_inline int capsule_mutex_create(capsule_mutex *res) {
@@ -128,21 +156,35 @@ Caml_inline int capsule_mutex_create(capsule_mutex *res) {
     return ENOMEM;
   }
   atomic_store_explicit(&mut->owner, FIBER_NONE, memory_order_relaxed);
+#ifdef __APPLE__
+  mut->sem = dispatch_semaphore_create(1);
+  if(mut->sem == NULL) {
+    caml_stat_free(mut);
+    return ENOMEM;
+  }
+#else
   // 0 = thread-shared, 1 = initial value
   if (sem_init(&mut->sem, 0, 1) != MUTEX_SUCCESS) {
     caml_stat_free(mut);
     return errno;
   }
+#endif
   *res = mut;
   return MUTEX_SUCCESS;
 }
 
 Caml_inline int capsule_mutex_destroy(capsule_mutex mut) {
+#ifdef __APPLE__
+  dispatch_release(mut->sem);
+  caml_stat_free(mut);
+  return MUTEX_SUCCESS;
+#else
   if (sem_close(&mut->sem) == MUTEX_SUCCESS) {
     caml_stat_free(mut);
     return MUTEX_SUCCESS;
   }
   return errno;
+#endif
 }
 
 #endif /* CAML_INTERNALS */
