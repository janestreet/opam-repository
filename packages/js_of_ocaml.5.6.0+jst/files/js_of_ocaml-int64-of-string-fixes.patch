--- a/runtime/int64.js
+++ b/runtime/int64.js
@@ -27,6 +27,10 @@
   this.mi = mi & 0xffffff;
   this.hi = hi & 0xffff;
 }
+MlInt64.UNSIGNED_MAX  = new MlInt64(0xffffff, 0xffffff, 0xffff);
+MlInt64.SIGNED_MAX    = new MlInt64(0xffffff, 0xffffff, 0x7fff);
+MlInt64.SIGNED_MIN    = new MlInt64(0x000000, 0x000000, 0x8000);
+
 MlInt64.prototype.caml_custom = "_j";
 MlInt64.prototype.copy = function () {
   return new MlInt64(this.lo, this.mi, this.hi);
@@ -339,12 +343,10 @@
     base = r[2],
     signedness = r[3];
   var base64 = caml_int64_of_int32(base);
-  var threshold = new MlInt64(0xffffff, 0xfffffff, 0xffff).udivmod(
-    base64,
-  ).quotient;
+  var threshold = MlInt64.UNSIGNED_MAX.udivmod(base64).quotient;
   var c = caml_string_unsafe_get(s, i);
   var d = caml_parse_digit(c);
-  if (d < 0 || d >= base) caml_failwith("int_of_string");
+  if (d < 0 || d >= base) caml_failwith("Int64.of_string");
   var res = caml_int64_of_int32(d);
   for (;;) {
     i++;
@@ -352,15 +354,15 @@
     d = caml_parse_digit(c);
     if (d < 0 || d >= base) break;
     /* Detect overflow in multiplication base * res */
-    if (caml_int64_ult(threshold, res)) caml_failwith("int_of_string");
+    if (caml_int64_ult(threshold, res)) caml_failwith("Int64.of_string");
     d = caml_int64_of_int32(d);
     res = caml_int64_add(caml_int64_mul(base64, res), d);
     /* Detect overflow in addition (base * res) + d */
-    if (caml_int64_ult(res, d)) caml_failwith("int_of_string");
+    if (caml_int64_ult(res, d)) caml_failwith("Int64.of_string");
   }
-  if (i != caml_ml_string_length(s)) caml_failwith("int_of_string");
-  if (signedness && caml_int64_ult(new MlInt64(0, 0, 0x8000), res))
-    caml_failwith("int_of_string");
+  if (i != caml_ml_string_length(s)) caml_failwith("Int64.of_string");
+  if (signedness && caml_int64_ult(sign < 0 ? MlInt64.SIGNED_MIN : MlInt64.SIGNED_MAX, res))
+    caml_failwith("Int64.of_string");
   if (sign < 0) res = caml_int64_neg(res);
   return res;
 }
